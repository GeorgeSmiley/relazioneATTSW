\chapter{Tecniche e framework utilizzati}
\section{Code versioning}
Per tenere traccia della storia dei codici di Server e Client abbiamo utilizzato il software \emph{git} creando una repository locale connessa a una repository remota su \emph{github}. La repository remota utilizzata \`e disponibile per la consultazione al seguente URL:
\begin{itemize}
	\item \url{https://github.com/alexfoglia1/attsw-server}
\end{itemize}
L'utilizzo di \emph{git} si \`e rivelato particolarmente utile per il lavoro in gruppo, grazie al meccanismo delle \emph{pull requests}. Il workflow che abbiamo seguito prevedeva di aprire un ramo ogni qualvolta un membro del gruppo volesse implementare una particolare \emph{feature} all'interno dei software. Abbiamo dunque realizzato sul master tutte le interfacce di cui gli applicativi faranno uso e creato un ramo per ogni loro singola implementazione. Quando una particolare implementazione veniva terminata, allora procedevamo al \emph{merge} del ramo sul master risolvendo gli eventuali conflitti generati, mediante l'interfaccia di \emph{github}.\\*
Non abbiamo sollevato alcuna \emph{issue} perch\`e abbiamo lavorato per la maggior parte del tempo nel medesimo luogo fisico.\\*
\emph{Git} \`e stato utilizzato sia da terminale, che tramite il plugin per eclipse \emph{e-git} che ci ha semplificato alcune operazioni.\\*
\section{Dependencies and build tool}
Per gestire le dipendenze e realizzare la build del codice, abbiamo utilizzato il software \emph{Apache Maven}, in particolare ne abbiamo utilizzato la sua integrazione nativa in eclipse.\\*
Dal momento che occorre fornire evidenze su metriche quali \emph{code coverage} e qualit\`a del codice abbiamo realizzato i seguenti profili Maven all'interno del POM con lo scopo di eseguire differenti processi di build in relazione ai particolari plugin che era necessario legare a ciascuna fase del ciclo di vita di Maven.
\begin{lstlisting}
clean verify -Pjacoco coveralls:report
clean verify -Pjacoco sonar:sonar
clean verify -Pfailsafe
\end{lstlisting}
Il profilo jacoco serve a generare i report sugli unit test e ad inviarli rispettivamente ai server di \emph{Coveralls} e di \emph{SonarQube} (\emph{SonarCloud}); mentre il profilo failsafe esegue sia gli unit test che gli integration test ed \`e proprio quest'ultima build quella che effettuiamo anche in locale. Dal momento che il codice del progetto si articola in 3 moduli (Client, Server, End2End), il comando di build viene eseguito nella directory del parent pom che accomuna i sopracitati moduli.
\section{Continuos integration}
Le repository elencate in 2.1 sono collegate al server di Continuos Integration \emph{Travis} attraverso il file \emph{.travis.yml}. Questo file rappresenta lo script che \emph{Travis} deve eseguire sulle macchine remote al fine di ricreare un ambiente in cui \`e possibile lanciare le stesse build che effettuiamo anche in locale. Per ricreare l'ambiente \emph{Travis} viene configurato in modo tale da usare il servizio Docker, ma \`e solo durante la build che viene lanciato il container Docker di MongoDB, in quanto il profilo failsafe, che deve eseguire gli integration test, \`e stato appositamente configurato per lanciare il container Docker legandone il relativo plugin alla fase \emph{pre-integration-test}. Dal momento che ciascuna build viene eseguita usando i profili jacoco e failsafe definiti nel POM, questa genera i report su \emph{Coveralls} e \emph{SonarCloud} sia nel caso in cui la build venga fatta in locale che sui server di \emph{Travis}. 
\section{Frameworks}
\subsection{Spring Boot}
Nel capitolo 1 si menziona Spring Boot quale framework utilizzato per realizzare il Server. Spring Boot \`e un particolare framework che facilita il programmatore nella realizzazione di una \emph{web-app} evitando allo stesso di utilizzare direttamente le Servlet Java. Spring Boot offre inoltre una libreria che implementa il design pattern \emph{Depencency Injection}, reso necessario dal meccanismo di \emph{Inversion of Control} sottostante una qualsiasi web-app Java. La \emph{Dependency Injection} \`e necessaria poich\'e springboot esegue la web-app all'interno di un web container il quale si trova a sua volta all'interno di un server, es. Tomcat. Infatti, proprio perch\'e la web-app viene lanciata all'interno di un web container, non possiamo avere il totale controllo sull'istanziazione degli oggetti a run-time.\\*Per questo motivo, Spring Boot, contestualmente al lancio dell'applicativo carica un particolare \emph{application-context} (contesto applicativo) il quale \`e l'insieme di tutti i bean che dovranno essere iniettati negli oggetti da essi dipendenti. Ogni bean iniettato \`e necessariamente un oggetto \emph{singleton}.
Le principali funzionalit\`a messe a disposizione da Spring Boot che abbiamo utilizzato sono le repository per i database e i controller per interfacciare la web-app verso l'esterno.\\*
Per realizzare il Server, al posto di eclipse, \`e stato utilizzato Spring Tool Suite, il quale ne rappresenta una versione modificata ad hoc.
\subsubsection{Scelta del database}
Spring Boot possiede librerie per gestire un ampio insieme di database; noi abbiamo scelto MongoDB in quanto funzionale alle necessit\`a dell'applicativo che intendevamo realizzare. MongoDB \`e un database NoSQL, questo implica che le entit\'a presenti al suo interno non devono rispettare alcun vincolo di integrit\'a realazionale, e questo ha particolarmente senso dal momento che nel database sono salvate istanze di griglie relazionalmente slegate l'una dall'altra. MongoDB \`e infine molto semplice da utilizzare ed integrare in una web-app.
\subsubsection{Template engine}
Spring Boot, per renderizzare le pagine html che un client pu\`o richiedere, utilizza l'engine \emph{Thymeleaf}.
\subsection{Framework di test}
Grazie alla sua facile integrazione con eclipse, gli unit test e gli integration test vengono eseguiti in locale utilizzando il framework \emph{Junit}. Per testare la corretta realizzazione dell'interfaccia utente di cui fa uso il Client abbiamo utilizzato il framework \emph{AssertJ}, che ci ha permesso di scrivere asserzioni sulle componenti grafiche realizzate.\\*
L'interfaccia del Client non \`e la sola interfaccia utente realizzata, infatti, come gi\`a specificato nel capitolo 1, il Server predispone un'interfaccia web dedicata alle operazioni CRUD sul database. Per testare questa interfaccia, che \`e necessariamente un'interfaccia HTML, abbiamo utilizzato il framework HtmlUnit. Per mockare le dipendenze delle classi durante il processo di test unitario abbiamo utilizzato il framework Mockito sia per il Client che per il Server.
\subsection{Http Client}
Per implementare le richieste HTTP del Client abbiamo scelto il framework \emph{Apache HttpClient} che mette a disposizione le classi necessarie per effettuare richieste HTTP su un particolare server (es. GET oppure POST) evitando di scrivere direttamente codice che usi le classiche Socket.
\subsection{GUI}
Il framework scelto per la realizzazione dell'interfaccia grafica \`e \emph{Swing}. Questo framework ci ha permesso di integrare Apache Http Client con una semplice interfaccia utente composta da una singola finestra (JFrame).
\subsection{End to end test}
Gli end to end test sono stati implementati usando Selenium per simulare la comunicazione browser-server; mentre Cucumber \`e il framework utilizzato per implementare gli end to end test secondo una tecnica BDD.