\chapter{Problemi incontrati}
In questo capitolo parleremo dei problemi che abbiamo incontrato sia durante la stesura del codice che durante l'utilizzo delle tecniche oggetto di questo corso.
\section{Integration test su Mac}
Abbiamo avuto un problema relativo all'esecuzione degli Integration Test dell'interfaccia grafica del client su Mac OS X. Il problema \`e stato risolto includendo nel POM un modulo della libreria AssertJ che era richiesto a run-time dal sistema Mac. Per essere poi sicuri che successive modifiche continuassero a non creare problemi su Mac OS, ne abbiamo abilitato la relativa build su travis grazie al meccanismo delle build \emph{matrix}.
\section{Build Mac del Server su Travis}
Come riportato nella documentazione di Travis, quest'ultimo non supporta l'utilizzo di Docker sulle macchine remote quando impostate per utilizzare Mac OS; pertanto siamo stati costretti a disabilitare la build su Mac per quanto riguarda il server.
\section{End to end test}
Per realizzare gli end to end test abbiamo scritto un Junit test case che utilizzasse un server non mockato. Tuttavia questa particolare circostanza impone che prima del lancio del test venga eseguito il server in locale, cosa non implementabile in automatico su Travis. Per risolvere questa problematica abbiamo escluso la classe riguardante gli end to end test dalla build di maven, ma l'abbiamo lasciata a disposizione per il suo lancio direttamente da eclipse. Al fine di verificare che gli end to end test passassero anche quando l'applicazione Server non risiede esclusivamente sulla stessa macchina locale in cui si lancia il Client (localhost) abbiamo eseguito il deploy dell'applicazione su heroku (all'indirizzo \url{http://attsw-server.herokuapp.com}) in modo tale da poter inserire questo URL negli end to end test al posto del semplice localhost.
\section{Utilizzo di due differenti database}
Abbiamo provato anche ad integrare un database MySQL all'interno del Server, tuttavia in corso d'opera sono sorti numerosi problemi le cui soluzioni avevano complicato troppo la struttura delle classi. I principali problemi incontrati sono stati:
\begin{itemize}
	\item Incongruenza di tipi: il tipo java intero viene mappato su un database MySQL come un long a 64 bit, mentre non esiste il tipo di dato matrice. Questo fatto ci aveva costretto a creare una seconda classe, compatibile con MySQL, che rappresentasse un'istanza di una griglia all'interno del database MySQL. 
	\item Differenti repository Spring: l'interfaccia IGridService vede esclusivamente DatabaseGrid, oggetti direttamente mappati all'interno del database Mongo tramite l'interfaccia nativa IMongoRepository. Questa interfaccia ha un suo equivalente per i database MySQL (CrudRepository) ma l'utilizzo dell'una e dell'altra interfaccia (IMongoRepository, CrudRepository) per le operazioni con il database aveva notevolmente complicato la struttura di IGridService, aggiungendovi una dipendenza esplicita da un'interfaccia \emph{Implementor}, da noi realizzata, la quale astraeva IMongoRepository e CrudRepository. 
	\item Testing del database: non siamo riusciti a testare le operazioni sul database quando effettuate su MySQL, infatti, sebbene a run-time gli oggetti venivano correttamente scritti sul database e letti dal database, durante i test le operazioni di scrittura mediante repository non producevano alcuna istanza all'interno del database. L'unica soluzione che siamo riusciti a trovare \`e stata quella di sostituire l'utilizzo della repository MySQL con l'utilizzo diretto di una query sul database; soluzione giudicata come fortemente sbagliata in quanto non utilizzava gli strumenti di Spring Boot.
\end{itemize} 
Per risolvere questi problemi abbiamo fatto un refactoring completo del codice su una nuova repository git. Approfittando di ci\`o abbiamo ripulito non solamente il codice dall'uso di MySQL, ma abbiamo avuto la possiblit\'a di realizzare meglio, grazie all'esperienza maturata in precedenza, anche le altre funzioni gi\'a realizzate sulla vecchia repository.
\section{Mutation testing con PitClipse}
Per effettuare mutation testing sugli unit-test abbiamo utilizzato il framework PitClipse, tuttavia quest'ultimo quando genera i mutanti del SUT, lo fa mutando anche classi che non fanno parte del SUT propriamente inteso per gli unit test. Questo problema ha fatto si che esistessero mutanti sopravvissuti nei report di PitClipse, ma tutti i mutanti sopravvissuti sono mutanti di classi che non sono \emph{under-test} nel test case in questione.
\section{Testing dell'interfaccia grafica}
Per verificare che quando doveva essere disegnato un punto nel pannello centrale del Client (GUIpanel), questo venisse effettivamente disegnato, abbiamo voluto verificare che venisse chiamato il metodo fillOval coi giusti argomenti su un oggetto Graphics. Mockito tuttavia permette di effettuare asserzioni sull'invocazione di un metodo solo su oggetti mockati o oggetti spiati. A run-time, l'oggetto Graphics usato da un JPanel per disegnare il proprio contenuto, \`e istanza di una particolare sottoclasse final di Graphics, quindi quest'ultimo non pu\`o essere n\'e mockato n\'e spiato. Per risolvere questa problematica abbiamo creato una classe Wrapper di Graphics che estende Graphics, spiato un'istanza di quest'ultima, e nei test abbiamo invocato il metodo paintComponent(Graphics) (metodo delegato al disegno del pannello) passandovi l'istanza spiata. In questo modo abbiamo potuto verificare che venissero invocati correttamente i metodi fillOval all'interno della classe GUIpanel.\\*
Infine, dover scrivere test sull'interfaccia grafica ci ha costretto a modificare l'interfaccia delle classi delegate alla renderizzazione grafica dei contenuti ricevuti dal REST controller del server: sono stati creati dei metodi non-privati per poter accedere alle informazioni necessarie al fine di poter scrivere asserzioni coerenti con il comportamento atteso dal sistema.
\section{End To End Testing}
Gli End to End test sono stati motivo di un importante cambiamento nella struttura del progetto. Iniziamente avevamo previsto di realizzare Client e Server come due progetti separati ed inserire gli EndToEnd come test di integrazione del Client. Questo si prestava poco bene al meccanismo di build automation (di fatto tali test erano esclusi dalla build) dunque abbiamo deciso di rifattorizzare l'intero progetto; creando un parent-pom avente come moduli il Server, il Client, e gli End to End test.\\
Al fine di poter popolare e resettare il database abbiamo creato due nuovi end point Rest, che ci consentono di effettuare facilmente il testing dell'applicazione nel caso in cui fossero presenti griglie nel database senza dover fare procedure strane per popolarlo; ed altres\`i ci consentono di ripulire facilmente il database al termine di ogni test.\\*
Per testare la comunicazione mediante GUI del nostro Client con il Server abbiamo usato, come per i test dell'interfaccia grafica, la libreria AssertJ, mentre per testare la comunicazione Browser con il server abbiamo utilizzato congiuntamente Selenium e Cucumber.\\*

